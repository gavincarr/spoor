#!/usr/bin/perl
#
# Spoor web service
#
# - accept posts via an api (json messages via HTTP POSTs)
# - simple interfaces for post listing and display (html and atom)
#

use strict;
use Mojolicious::Lite;
use Encode;
use XML::Atom;
use XML::Atom::Feed;

plugin 'basic_auth';

use FindBin qw($Bin);
use lib "$Bin/lib";
use lib 'lib';
use Spoor::Config;
use Spoor::Util qw(get_schema ts2iso8601_offset);

# -------------------------------------------------------------------------
# Config
#

my $config = Spoor::Config->new;
my $spoor_url = $config->get('url')
  or die "Missing 'url' setting in spoor.conf\n";

my $secret = $config->get('secret')
  or die "Missing 'secret' setting in spoor.conf\n";
app->secret($secret);

my $title = $config->get('title') || 'Spoor microblog';

my $schema = get_schema($config->get('environment'));

# -------------------------------------------------------------------------
# Collective GET routes
#
# GET /

helper render_html => sub {
  my ($self) = @_;

  my $publish_delay = ($config->get('publish_delay') || 180) + 30;
  $self->stash(publish_delay    => $publish_delay);
  $self->stash(js_list          => [ qw(post.js) ]);
  $self->stash(ts_cutoff_epoch  => time - $publish_delay);
  $self->stash(title            => $title);

  $self->render('index');
};

helper render_atom => sub {
  my ($self, $rs, $path) = @_;

  $XML::Atom::DefaultVersion = "1.0";

  my $new_feed = sub {
    my $feed = XML::Atom::Feed->new;
    $feed->title($title);
    $feed->id($spoor_url . $path);
    return $feed;
  };
  my $feed = $new_feed->();

  while (my $post = $rs->next) {
    # If we find a post that is paused, reset the feed and start again with next
    if ($post->pause_b) {
      $feed = $new_feed->();
      next;
    }

    my $id = $post->id;
    my $entry = XML::Atom::Entry->new;
    $entry->id("$spoor_url/post/$id");
    $entry->title($post->post_processed);
    $entry->content($post->post_processed);
    $entry->published(ts2iso8601_offset($post->timestamp, $config->get('publish_delay') || 180));
    $feed->add_entry($entry);
  }

  $self->render(format => 'xml', text => $feed->as_xml);
};

helper render_rs => sub {
  my ($self, $path, $rs) = @_;

  $rs ||= $schema->resultset('Post')->search({
    delete_b    => 0,
  }, {
    order_by    => 'timestamp desc',
    rows        => $config->get('display_limit') || 100,
  });
  return '' unless $rs;

  my $format = $self->stash('format') || '';
  if ($format eq 'atom') {
    $self->render_atom($rs, "$path.atom");
  }

  else {
    $self->stash(rs => $rs);
    $self->render_html(template => 'index');
  }
};

get '/' => sub {
  my $self = shift;
  $self->render_rs('/index');
} => 'index';

get '/index' => sub {
  my $self = shift;
  $self->render_rs('/index');
};

get '/tag/:tag' => sub {
  my $self = shift;
  my $tag = $self->param('tag');

  my $rs = $schema->resultset('Post')->search({
    'tag.type'  => '#',
    'tag.tag'   => $tag,
    delete_b    => 0,
  }, {
    order_by    => 'timestamp desc',
    join        => { post_tags => 'tag' },
    rows        => $config->get('display_limit') || 100,
  });
  return '' unless $rs;

  $self->render_rs("/tag/$tag", $rs);
};

# -------------------------------------------------------------------------
# Individual post GET routes
#
# GET    /post/<id>
# GET    /post/<id>.json
#

helper render_json_post => sub {
  my ($self, $id) = @_;

  my $rs = $schema->resultset('Post');
  $rs->result_class('DBIx::Class::ResultClass::HashRefInflator');
  my $post = $rs->find($id)
    or return $self->render(status => 403,
      json => { error => "Invalid post '$id'" });

  delete $post->{post_processed};
  $post->{post} = delete $post->{post_raw};

  $self->render_json($post);
};

get '/post/:id' => [format => [ 'json' ]] => sub {
  my $self = shift;
  $self->render_json_post($self->param('id'));
};

get '/post/:id' => sub {
  my $self = shift;
  my $id = $self->param('id');

  my $post = $schema->resultset('Post')->find($id)
    or $self->render('notfound');

  $self->stash(title    => $title);
  $self->stash(post     => $post);
  $self->stash(js_list  => undef);
} => 'display';

# -------------------------------------------------------------------------
# Authentication

helper 'login' => sub {
  my $self = shift;
  my $log = app->log;

  my $conf_username = $config->get('username');
  my $conf_password = $config->get('password');
  unless (defined $conf_username && defined $conf_password) {
    $log->warn("Config 'username' parameter not defined") if ! defined $conf_username;
    $log->warn("Config 'password' parameter not defined") if ! defined $conf_password;
    return 0;
  }

  return 1 if $self->basic_auth(
    Spoor => sub {
      my ($user, $pass) = @_;
      unless (defined $user && defined $pass) {
        $log->warn("No 'user' parameter passed to basic_auth checking") if ! defined $user;
        $log->warn("No 'pass' parameter passed to basic_auth checking") if ! defined $pass;
        return 0;
      }

      $log->debug("Checking user '$user', pass '$pass' ...");
      if ($user eq $conf_username && $pass eq $conf_password) {
        $log->info("User/pass found and good, setting session for $user");
        $self->session(user => $user);
        return 1;
      }
    },
  );

  return 0;
};

get '/login' => sub {
  my $self = shift;
  if ($self->login) {
    $self->redirect_to('index');
  }
  else {
    $self->stash(title => 'Login unsuccessful');
    $self->stash(js_list => undef);
    $self->render(template => 'badlogin');
  }
} => 'login';

get '/logout' => sub {
  my $self = shift;
  $self->session(expires => 1);
  $self->redirect_to('index');
};

# Everything below here requires authentication
under sub {
  my $self = shift;
  return $self->login;
};

# -------------------------------------------------------------------------
# POST and DELETE routes
#
# POST   / - post message
# DELETE /post/<id> - delete
# POST   /post/<id> - partial updates (yes I know, not entirely restful ...)
#          post  => 'updated post'
#          pause => 0/1
#          delete => 0
#

# Top-level api route, processing json POST posts
helper api_post => sub {
  my $self = shift;
  my $content_type = $self->req->headers->content_type;

  # TODO: why aren't json bodies automatically deserialised into params?
  my $text;
  if ($content_type =~ /\bjson$/) {
    my $params = $self->req->json
      or return $self->render(status => 403,
        json => { error => "Not a json request?" });
    $text = $params->{post} || $params->{status}
      or return $self->render(status => 403,
        json => { error => "Missing 'post' or 'status' parameter?" });
  }
  else {
    $text = $self->param('post') || $self->param('status')
      or return $self->render(status => 403,
        text => "Missing 'post' or 'status parameter?");
  }

  my $post_content = Encode::decode_utf8($text);
  my $post = $schema->resultset('Post')->create({
    post_raw => $post_content,
  }) or return $self->render(status => 500,
    json => { error => "Creating post failed" });

  my $post_url = "${spoor_url}/post/" . $post->id;

  if ($content_type =~ /\bjson$/) {
    $self->render_json({ status => {
      id      => $post->id,
      text    => $post->post_raw,
      url     => $post_url,
    }});
  }
  else {
    $self->redirect_to($config->get('url'));
  }
};

# Top-level post
#post '/index.json' => sub {
post '/' => sub {
  my $self = shift;
  return $self->api_post;
};

# Twitter-compatible api post route
post '/statuses/update' => sub {
  my $self = shift;
  return $self->api_post;
};

# Update post (partial, not pull PUT)
post '/post/:id' => sub {
  my $self = shift;
  my $id = $self->param('id');

  my $post = $schema->resultset('Post')->find($id)
    or return $self->render(status => 403,
      json => { error => "Invalid post '$id'" });

  my %param_map = (
    post    => 'post_raw',
    pause   => 'pause_b',
    delete  => 'delete_b',
  );
  my %update;
  for my $p (keys %param_map) {
    my $val = $self->param($p);
    if (defined $val && $val ne '') {
      $update{ $param_map{$p} } = Encode::decode_utf8( $val );
    }
  }
  if (keys %update) {
    $post->update( \%update )
      or return $self->render(status => 500,
        json => { error => "Update failed: $!" });

    $self->render_json_post($post->id);
  }

  else {
    return $self->render(status => 403,
      json => { error => "No valid parameters found [post|pause|delete]" });
  }
};

del '/post/:id' => sub {
  my $self = shift;
  my $id = $self->param('id');

  my $post = $schema->resultset('Post')->find($id)
    or $self->render('notfound');

  $post->update({ delete_b => 1 });

  $self->render(status => 204, json => { msg => 'Deleted' });
};

# -------------------------------------------------------------------------

app->start;

